package vn.com.project.services.employee.model;

import domainapp.basics.model.meta.DAttr;

import java.util.ArrayList;
import java.util.Collection;

import domainapp.basics.exceptions.ConstraintViolationException;
import domainapp.basics.model.meta.AttrRef;
import domainapp.basics.model.meta.DAssoc;
import domainapp.basics.model.meta.DAttr.Type;
import domainapp.basics.util.Tuple;
import domainapp.basics.model.meta.DClass;
import domainapp.basics.model.meta.DOpt;
import domainapp.basics.model.meta.Select;
import domainapp.basics.model.meta.DAssoc.AssocEndType;
import domainapp.basics.model.meta.DAssoc.AssocType;
import domainapp.basics.model.meta.DAssoc.Associate;

@DClass(schema = "project")
public class Address {

	public static final String A_name = "name";

	@DAttr(name = "id", id = true, auto = true, length = 3, mutable = false, optional = false, type = Type.Integer)
	private int id;
	private static int idCounter;

	@DAttr(name = A_name, type = Type.String, length = 20, optional = true, cid = true)
	private String name;

	@DAttr(name="employees",type=Type.Collection,optional = false,
		      serialisable=false,filter=@Select(clazz=Employee.class))
		  @DAssoc(ascName="address-has-employees",role="address",
		      ascType=AssocType.One2Many,endType=AssocEndType.One,
		    associate=@Associate(type=Employee.class,cardMin=0,cardMax=30))
		  private Collection<Employee> employees; 
	
	private int employeeCount;

	// from object form: Employee is not included
	@DOpt(type = DOpt.Type.ObjectFormConstructor)
	@DOpt(type = DOpt.Type.RequiredConstructor)
	public Address(@AttrRef("name") String addressName) {
		this(null, addressName, null);
	}

	// from data source
	@DOpt(type = DOpt.Type.DataSourceConstructor)
	public Address(@AttrRef("id") Integer id, @AttrRef("name") String addressName) {
		this(id, addressName, null);
	}

	// based constructor (used by others)
	private Address(Integer id, String addressName, Employee employee) {
		this.id = nextId(id);
		this.name = addressName;
		employees = new ArrayList<>();
	}

	private static int nextId(Integer currID) {
		if (currID == null) {
			idCounter++;
			return idCounter;
		} else {
			int num = currID.intValue();
			if (num > idCounter)
				idCounter = num;

			return currID;
		}
	}
	
	/**
	   * @requires 
	   *  minVal != null /\ maxVal != null
	   * @effects 
	   *  update the auto-generated value of attribute <tt>attrib</tt>, specified for <tt>derivingValue</tt>, using <tt>minVal, maxVal</tt>
	   */
	  @DOpt(type=DOpt.Type.AutoAttributeValueSynchroniser)
	  public static void updateAutoGeneratedValue(
	      DAttr attrib,
	      Tuple derivingValue, 
	      Object minVal, 
	      Object maxVal) throws ConstraintViolationException {
	    
	    if (minVal != null && maxVal != null) {
	      //TODO: update this for the correct attribute if there are more than one auto attributes of this class 
	      int maxIdVal = (Integer) maxVal;
	      if (maxIdVal > idCounter)  
	        idCounter = maxIdVal;
	    }
	  }
	  
	  public int getId() {
	    return id;
	  }
	  
	  public String getName() {
	    return name;
	  }
	 

	  /**
	   * A link-adder method for {@link #students}, required for the object form to function.
	   * However, this method is empty because students have already be recorded in the attribute {@link #students}.
	   */
	  @DOpt(type=DOpt.Type.LinkAdder)
	  public boolean addEmployee(Collection<Employee> employees) {
	    // do nothing
	    return false;
	  }
	  
	  /**
	   * @effects return students
	   */
	  public Collection<Employee> getEmployees() {
	    return employees;
	  }
	  
	  public void setName(String name) {
		  this.name = name;
	  }
	  
	  @DOpt(type=DOpt.Type.LinkAdder)
	  public boolean addEmployee(Employee e) {
		  if (!employees.contains(e)) {
			  employees.add(e);
		  }
		  return false;
	  }
	  
	  @DOpt(type=DOpt.Type.LinkAdderNew)
	  public boolean addNewEmployee(Employee e) {
		  employees.add(e);
		  
		  employeeCount++;
		  
		  return false;
	  }
	  

	  
	  @DOpt(type=DOpt.Type.LinkAdderNew)
	  public boolean addNewEmployee(Collection<Employee> ems) {
		  employees.addAll(ems);
		  employeeCount+=ems.size();
		  return false;
	  }
	  
	  @DOpt(type=DOpt.Type.LinkRemover)
	  public boolean removeEmployee(Employee e) {
		  boolean removed = employees.remove(e);
		  
		  if (removed) {
			  employeeCount--;
		  }
		  return false;
	  }
	  
	  public void setEmployee(Collection<Employee> em) {
		  this.employees = em;
		  employeeCount = em.size();
	  }
	  
	  @DOpt(type=DOpt.Type.LinkCountGetter)
	  public Integer getEmployeeCount() {
		  return employeeCount;
	  }
	  
	  @DOpt(type=DOpt.Type.LinkCountSetter)
	  public void setEmployeeCount( int count) {
		  employeeCount = count;
	  }

	  @Override
	  public String toString() {
	    return name;
	  }
}
